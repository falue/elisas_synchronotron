/* autogenerated by Processing revision 1290 on 2023-09-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import controlP5.*;
import processing.io.*;
import hypermedia.net.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class elisas_synchronotron extends PApplet {

/*
  Elisas Strange Case - Processing sketch 
  =====================================================

  By f.l\u00fcscher / fluescher.ch 2023 for Next Level Escape AG.
  "AS IS" pi pa po etc.

  Main file.
  Run this with processing.org/download on mac/win/linux/raspberry pi.
  When not on raspberry pi with GPIO pins and 4 connected rotary encoders,
    set GPIO_AVAILABLE to false and DEBUG to true.
  press 0-6 or arrow keys to change stages.
  esc or right mouse button to leave.

  STAGES
  #   Action                                                  At end of script..
  0:  Blackout                                                ..waits for dungeon master / udp signal
  1:  Message"AWAITING INPUT"                                 ..waits for dungeon master / udp signal
  2:  Startup sequence of computer                            ..auto-jumps to next stage
  3:  Elisas curves, but without brainalizer on players head  ..waits for dungeon master / udp signal
  4:  Elisas curves, with brainalizer. Adjust dials to sync.  ..jumps to next stage when synched
  5:  Message "SUCCESS"                                       ..waits for dungeon master / udp signal
  6:  Elisas thoughts as sequence in DE & EN                  ..waits for dungeon master / udp signal

  UDP & WINNING NUMBERS
  Refer to the README.md file to see messages that are sent and being received.

  IF LIBRARIES MISSING
    No library found for controlP5       -> in library manager look for "controlP5"
    No library found for processing.io   -> in library manager look for "processing-io"
    No library found for hypermedia.net  -> in library manager look for "UDP" by Stephane Cousot (!!)
*/



//// FROM HERE: ADJUST FOR PREFERENCES -----------------------

// GLOBALS
boolean GPIO_AVAILABLE = true;   // True for raspberry pi or computers with GPIOs
boolean DEBUG = false;           // Display infos and dials to play without GPIO
boolean CROSSHAIR = false;       // To calibrate monitors; displays frames and centerlines etc
boolean AUTOSCALE = false;       // If preloading takes ages or never finishes, turn this on.
                                 //   It rescales the viewing window until a framerate of 10 is matched.

// UDP settings
// FIXME: ip should be localIp (IP of this raspberry)
String remoteIp = "192.168.178.40";  // IP of controller mac
int remotePort = 53545;
// remoteIp, remotePort

String ip = "192.168.1.226";       // The remote IP address - your local network. Should be static.
int port = 53545;  // 53544; ??????                 // The destination port
int portIncoming = 53544;         // Port to listen to for incoming messages

// GAME MECHANICS
// Initial "wrong" values
// Note, to adjust these numbers, enable DEBUG
//   and enter the numbers on the dials, not the one in the orange dialog box.
int amplitude = 12;
int frequency = 80;
int scale = 24;
int noise = 380;
// Min/Max values
int ampMin = 0;
int ampMax = 50;
int freqMin = 65;
int freqMax = 333;
int scaleMin = 4;
int scaleMax = 75;
int noiseMin = -420;
int noiseMax = 420;
// Winning numbers on dials (also, initial adjustments for elisas curves)
int ampWin = 12;    // In GUI +333: 345
int freqWin = 183;  // In GUI +124: 307
int scaleWin = 12;  // In GUI +0:    12
int noiseWin = 8;   // In GUI +416: 424

// Tolerance +/- of user input to accomplish total brain synchronicity
//   the higher, the easier it is to win.
int ampTolerance = 18;
int freqTolerance = 18;
int scaleTolerance = 10;
int noiseTolerance = 50;

// Factor to increase speed of dials ("less turning, more changing" etc)
int ampDialSpeedFactor = 1;
int freqDialSpeedFactor = 1;
int scaleDialSpeedFactor = 1;
int noiseDialSpeedFactor = 8;

// For resetting stage - dont touch 
int amplitudeReset = amplitude;
int frequencyReset = frequency;
int scaleReset = scale;
int noiseReset = noise;

// STYLES
int wHeight = 240;                         // windowed content in frame to trick the 2x2 video wall converter
int mainBg = color(0,0,0);                 // RGB values
int mainFontColor = color(255,182,0);      // RGB values
int mainBgInitial = mainBg;                // used after invertig foreground & background. leave alone.
int mainFontColorInitial = mainFontColor;  // used after invertig foreground & background. leave alone.
int fontSize = wHeight/30;
int lineHeight = PApplet.parseInt(fontSize*1.4f);
int lineWeight = 2;


//// FROM HERE: DONT TOUCH -----------------------

// GENERAL
int stage = 0;                // keeps track of stages
int maxStage = 6;

// CLUTCHES
boolean startUpLoaded = false;
PImage cursorImg;


public void setup() {
  //size(640,480);  // VGA
  /* size commented out by preprocessor */;

  cursorImg = loadImage("cursor.gif");

  udpSetup();
  if(GPIO_AVAILABLE) gpioSetup();

  // Font
  PFont font;
  // The font must be located in the sketch's 
  // "data" directory to load successfully
  // font = createFont("3270SemiCondensed-Regular.otf", fontSize);
  // font = createFont("3270-Regular.otf", fontSize);        // too thin :(
  // font = createFont("ONESIZE_.TTF", fontSize);            // mokey island - no box chars :(
  // font = createFont("MonkeyIsland-1991", fontSize);       // mokey island, more chars (umlaute) - but doesn't work and still no box chars :(
  // font = createFont("Flexi_IBM_VGA_True.ttf", fontSize);  // no pixelation but real IBM :(
  font = createFont("Topaz8-xxO8.ttf", fontSize);            // maybe the one
  textFont(font);

  if(DEBUG) {
    debugSetup();
  }

  popUp("Installed version: "+version, width/4, 8*lineHeight, 6000);

  prepareExitHandler();
}


public void draw() {
  background(mainBg);
  // frameRate(12);

  // Exit processing sketch by pressing right mouse button
  if (mousePressed && (mouseButton == RIGHT)) {
    exit(); 
  }

  if(DEBUG) {
    debug();
    // if(!startUpLoaded) udp.send("sync_ready", ip, port);
    // startUpLoaded = true;  // Do not preload for debugging
  } else {
    cursor(cursorImg);  // Set to transparent png
    noCursor();         // Doesn't work at all on MAC
  }

  if(GPIO_AVAILABLE) gpioRead();

  if(stage == 0) {
    // Reset LED of button
    if(GPIO_AVAILABLE) GPIO.digitalWrite(switchLedPin, GPIO.LOW);

    // BLACKOUT
    if(DEBUG) {
      centerText("[BLACKOUT]", wHeight/2, 0,width/2);
      centerText("[BLACKOUT]", wHeight/2, width/2,width);
    }
  }

  if(stage == 1) {
    // AWAITING INPUT
    if (millis() % 1000 <= 500) {
      popUp("AWAITING INPUT", width/4, 0);
      popUp("AWAITING INPUT", width/4*3, 0);
    }

    // Catch main btn switch
    if(GPIO_AVAILABLE) {
      if(GPIO.digitalRead(mainSwitchPin) == GPIO.LOW) {
        GPIO.digitalWrite(switchLedPin, GPIO.HIGH);
        while(GPIO.digitalRead(mainSwitchPin) == GPIO.LOW) {
          // twiddle thumbs until user releases button
          delay(25);
        }
        nextStage();
        delay(500);
      } else {
        GPIO.digitalWrite(switchLedPin, GPIO.LOW);
      }
    }
  }

  if(stage == 2) {
    // Startup sequence
    scrollText(boot, 180, 350, 25,25, width/2-50, wHeight-50, false);
    scrollText(boot, 180, 350, width/2+25,25, width/2-50, wHeight-50, false);
  }

  if(stage == 4 || stage == 5) {
    // Kappe auf
    if(DEBUG) centerText("XXXXX USER]", wHeight/2, width/2+100,width);
    drawCurve(curve, width/2+25,lineHeight*2, width/2-50, wHeight-lineHeight*4, scale, amplitude, frequency, noise);
    
    if( stage == 4 &&
      isAboutEqual(amplitude, ampWin, ampTolerance) &&
      isAboutEqual(frequency, freqWin, freqTolerance) &&
      isAboutEqual(noise, noiseWin, noiseTolerance) &&
      isAboutEqual(scale, scaleWin, scaleTolerance)
    ) {
      // Player has synced brains properly
      // Ascend
      nextStage();
      
      // Send the good message to the controlino
      udp.send("/cue/sync_success/start", remoteIp, remotePort );
    }
  }

  if(stage == 3 || stage == 4 || stage == 5) {
    if(DEBUG) centerText("[SCREEN ELISA]", wHeight/2, 0,width/2);
    if(DEBUG) centerText("[SCREEN EMPTY]", wHeight/2, width/2,width);

    /* if (millis() % 1000 <= 50 && hasTakenScreenshot) {
      ghostingPaste(screenshot[0], 25,75, width/2-50, wHeight-100);
      ghostingPaste(screenshot[1], width/2+25,75, width/2-50, wHeight-100);
    } */

    // Elisas curve
    // ampWin, freqWin, scaleWin, noiseWin
    drawCurve(curve, 25,lineHeight*2, width/2-50, wHeight-lineHeight*4, scaleWin, ampWin, freqWin, noiseWin);

    if(stage == 3) {
      // display "disconnected" data with low noise
      drawCurve(nullCurve, width/2+25,lineHeight*2, width/2-50, wHeight-lineHeight*4, scale, amplitude, frequency, noise/20);
    }
    
    // Grids
    drawGrid(25,lineHeight*2, width/2-50, wHeight-lineHeight*4, scaleWin);
    drawGrid(width/2+25,lineHeight*2, width/2-50, wHeight-lineHeight*4, scale);
    /*
    MakeShadowOfBothCurves();
    } */
    drawFakeApplicationNonsense(0);
    drawFakeApplicationNonsense(width/2);

    /* if (millis() % 1000 <= 50) {
      hasTakenScreenshot = true;
      screenshot[0] = ghostingCopy(25,75, width/2-50, wHeight-100);
      screenshot[1] = ghostingCopy(width/2+25,75, width/2-50, wHeight-100);
    } */
  }

  if(stage == 5) {
    // SUCCESS
    // FLIP COLORS
    if (millis() % 1000 <= 500) {
      mainFontColor= color(mainBgInitial);
      mainBg = color(mainFontColorInitial);
    } else {
      mainBg = color(mainBgInitial);
      mainFontColor = color(mainFontColorInitial);
    }

    popUp(">BRAIN SYNC ESTABLISHED", width/4, 0);
    popUp(">BRAIN SYNC ESTABLISHED", width/4*3, 0);
  }

  if(stage == 6) {
    // Elisas thoughts sequence
    scrollText(thoughtsDe, 2000, 0, 25,25, width/2-50, wHeight-50, true);
    scrollText(thoughtsEn, 2000, 0, width/2+25,25, width/2-50, wHeight-50, true);
  }

  if(!startUpLoaded) {
    preloadAllStages(16);
  }

  if(DEBUG) {
    debugTail();
  }

  // Display Pop ups longer than triggered
  popUpAfterglow();
}

// Send message from the grave if closed or is mauled by death or bad programming
private void prepareExitHandler () {
  // TODO: Most of the time, port closes befoore this gets executed but meh
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
    public void run () {
      println("Program closed or died");
      udp.send("/cue/sync_died/start", remoteIp, remotePort);
    }
  }));
}

public void goToStage(int index) {
  // reset global stuffs
  scrollIndex = 0;  // reset index of text scroller
  mainBg = color(mainBgInitial);  // FLIP COLORS BACK
  mainFontColor = color(mainFontColorInitial);  // FLIP COLORS BACK
  stage = index;

  if(GPIO_AVAILABLE) {
    if(stage >= 2) GPIO.digitalWrite(switchLedPin, GPIO.HIGH);
    if(stage <= 1) GPIO.digitalWrite(switchLedPin, GPIO.LOW);
  }
}

public void nextStage() {
  // reset global stuffs
  scrollIndex = 0;  // reset index of text scroller
  mainBg = color(mainBgInitial);  // FLIP COLORS BACK
  mainFontColor = color(mainFontColorInitial);  // FLIP COLORS BACK

  if(stage+1 == 3 || stage+1 == 6) {
    // Reset values when entering brainalizer territorium or leaving "success" page
    amplitude = amplitudeReset;
    frequency = frequencyReset;
    scale = scaleReset;
    noise = noiseReset;
  }

  if(stage+1 == 4) popUp(">BRAINALIZER CONNECTED", width/4*3, 2500);
  if(GPIO_AVAILABLE) {
    if(stage+1 >= 2) GPIO.digitalWrite(switchLedPin, GPIO.HIGH);
    if(stage+1 == 1) GPIO.digitalWrite(switchLedPin, GPIO.LOW);
  }
  if(stage+1 <= maxStage) {
    stage++;
  } else {
    stage = 0;
    if(GPIO_AVAILABLE) GPIO.digitalWrite(switchLedPin, GPIO.LOW);
  }
}
public void prevStage() {
  // reset global stuffs
  scrollIndex = 0;  // reset index of text scroller
  mainBg = color(mainBgInitial);  // FLIP COLORS BACK
  mainFontColor = color(mainFontColorInitial);  // FLIP COLORS BACK

  if(stage-1 == 3) popUp(">BRAINALIZER DISCONNECTED", width/4*3, 1250);
  if(GPIO_AVAILABLE) {
    if(stage-1 >= 2) GPIO.digitalWrite(switchLedPin, GPIO.HIGH);
    if(stage-1 <= 1) GPIO.digitalWrite(switchLedPin, GPIO.LOW);
  }

  if(stage-1 >= 0) {
    stage--;
  } else {
    stage = maxStage;
  }
}
String version = "1.61";

String[] boot = {
    "00512 KB OK_",
    "RXN SYNCHRONOTRON link version 1.08",
    "",
    "  Port=LPT1",
    "    Drive Letters redirected: 3",
    "                (D: through F:)",
    "    Brainalizer ports redirected:  1",
    "                             (LPT3:)",
    "",
    "    This Computer  Other Computer",
    "      (Client)        (Server)",
    "    ------------  -----------------",
    "      D:   equals   A:",
    "      E:   equals   B:",
    "      F:   equals   C: (1054Mb)",
    "",
    "The RXN Brainwave diagnostics tool",
    "DIAGNOSTICS",
    "VERSION 2.83",
    "(C)Copyright RXN Corp. 1981,1985",
    "",
    "C>path=c:\\dos;c:\\nc4",
    "",
    "C>c:\\gm6\\gbrainalizer",
    "",
    "\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557",
    "\u2551 Dynamic brain synchronotron (v9.06)  \u2551",
    "\u2551             (C) 1981-1985 RXN Corp.  \u2551",
    "\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d",
    "Serial synchronotron (brain I/O systems",
    "mode) installed on COM1:",
    "(Port address is 3F8, IRQ number is 04)",
    "",
    "C>nc",
    "The RXN Brainwave diagnostics tool,",
    "Copyright 1925 to 1985, RXN Inc.",
    "",
    "",
    "Loading..",
    ""
};

String[] thoughtsDe = {
    "Hallo?... Ist da jemand? k\u00f6nnt ihr mich",
    "h\u00f6ren? Zum Gl\u00fcck seid ihr gekommen...",
    "Ich brauche eure Hilfe.",
    "Ich habe wirklich grosse Angst.",
    "Ich weiss nicht, was mit mir geschieht,",
    "aber ich transformiere mich in eine",
    "Puppe. Ihr m\u00fcsst in meine Erinnerungen",
    "eintauchen und herausfinden was mit mir",
    "passiert ist.",
    "",
    "Bitte, ihr seid meine letzte Hoffnung !!",
    "Aber Vorsicht! Ihr d\u00fcrft auf keinen Fall...",
    ""
};

String[] thoughtsEn = {
    "Hello? is anyone there? Can you hear me?",
    "Im so happy you guys are here.",
    "I need your help.",
    "Im really scared. I don't know what is",
    "happening to me but im transforming into",
    "a doll.",
    "",
    "You have to travel into my memories and ",
    "find out what happened to me.",
    "",
    "Please, you are my last hope.",
    "But careful! you should never...",
    ""
};

/* int[] curve = {
    532, 527, 522, 517, 522, 527, 532, 537, 542, 547, 552, 558, 563, 568, 573, 578, 583, 593, 614, 624, 634, 645, 650, 655, 665, 675, 680, 701, 716, 721, 727, 732, 737, 742, 747, 752, 757, 762, 757, 752, 737, 732, 706, 691, 645, 599, 506, 476, 445, 424, 389, 373, 348, 337, 332, 343, 363, 424, 537, 675, 767, 829, 849, 855, 860, 865, 870, 865, 860, 849, 839, 824, 752, 696, 675, 645, 639, 645, 650, 660, 665, 686, 701, 706, 711, 686, 675, 660, 655, 634, 624, 599, 558, 547, 532, 527, 522, 517, 511, 506, 496, 491, 476, 471, 460, 455, 450, 440, 435, 419, 414, 409, 404, 399, 404, 409, 414, 430, 440, 450, 460, 465, 471, 481, 486, 491, 496, 501, 506, 511, 517, 522, 527, 522, 517, 511, 506, 501, 506, 511, 517, 522, 527, 532, 537, 532, 527, 522
}; */

int[] nullCurve = {
    222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222,222
};

int[] curve = {
    283,
    281,
    282,
    280,
            666,
    281,
20,
    279,
        333,
    279,
        555,
188,
        444,
    277,
66,
      300,
    276,
    278,
    276,
    278,
    277,
    279,
        400,
    279,
    281,
    279,
    281,
66,
    285,
    285,
            850,
    287,
    288,
        666,
    284,
    286,
    286,
        465,
    286,
    288,
88,
    289,
    287,
    289,
    290,
        555,
    290,
    289,
    289,
    288,
    288,
    289,
    289,
    289,
    291,
    290,
    289,
    290,
        444,
    290,
100,
    289,
    289,
    290,
    289,
        333,
    291,
    289,
    288,
    286,
200,
    287,
    287,
    285,
    283,
        777,
    284,
    285,
    286,
    286,
    287,
    289,
    288,
    287,
    288,
    290,
    292,
    293,
    295,
    293,
    294,
    292,
    291,
    290,
    292,
    290,
    290,
    292,
    291,
    293
};

ControlP5 gui;
// https://sojamo.de/libraries/controlP5/#examples

Button nextBtn, prevBtn;  // brainalizerBtn,  // For later use to show/hide btn


public void debugSetup() {
    gui = new ControlP5(this);

    gui.addKnob("amplitudeKnob")
        .setLabel("AMPLITUDE")
        .setRange(ampMin,ampMax)
        .setValue(amplitude)
        .setPosition(20,20)
        .setRadius(30)
        .setDragDirection(Knob.VERTICAL)
        ;

    gui.addKnob("frequencyKnob")
        .setLabel("FREQUENCY")
        .setRange(freqMin,freqMax)
        .setValue(frequency)
        .setPosition(120,20)
        .setRadius(30)
        .setDragDirection(Knob.VERTICAL)
        ;

    gui.addKnob("scaleKnob")
        .setLabel("SCALE")
        .setRange(scaleMin,scaleMax)
        //.setValue(scale*width)
        .setValue(scale)
        .setPosition(220,20)
        .setRadius(30)
        .setDragDirection(Knob.VERTICAL)
        ;

    gui.addKnob("noiseKnob")
        .setLabel("DE-NOISE")
        .setRange(noiseMin,noiseMax)
        .setValue(noise)
        .setPosition(320,20)
        .setRadius(30)
        .setDragDirection(Knob.VERTICAL)
        ;


    nextBtn = gui.addButton("nextStage")  // same as function name 
        .setLabel("Next")  // overwrite btn text
        .setPosition(right(100, 20),20)
        .setSize(100,20)
        .setVisible(true);

    prevBtn = gui.addButton("prevStage")  // same as function name 
        .setLabel("Prev")  // overwrite btn text
        .setPosition(right(100, 20),45)
        .setSize(100,20)
        .setVisible(true);

    /* brainalizerBtn = gui.addButton("brainalizer")  // same as function name 
        .setLabel("Connect brainalizer")  // overwrite btn text
        .setPosition(right(100, 20),70)
        .setSize(100,40)
        .setVisible(false); */
}

// in draw()
public void debug() {
    stroke(mainFontColor);
    line(width/2,0, width/2,wHeight);  // vertical monitor separator

    if(CROSSHAIR) {
        // arrows
        fill(mainFontColor);
        triangle(0,0, 25,15, 15,25);
        triangle(width,0, width-25,15, width-15,25);
        triangle(width,wHeight, width-25,wHeight-15, width-15,wHeight-25);
        triangle(0,wHeight, 25,wHeight-15, 15,wHeight-25);

        // cross
        stroke(mainFontColor);
        line(0,wHeight/2, width,wHeight/2);  // horz 
        line(0,0, width,wHeight);  // diagonal
        line(0,wHeight, width,0);  // diagonal
        
        // center
        fill(0,0,0,0);
        rect(0,0, width-1,wHeight-1);
        rect(0,0, width-1,height-1);
        rect(width/2-50,wHeight/2-50, 100,100);
        rect(width/4-50,wHeight/2-50, 100,100);
        rect(width/4*3-50,wHeight/2-50, 100,100);
    }
}

public void debugTail() {
    textAlign(RIGHT);
    textSize(fontSize*2); 
    fill(mainFontColor);
    text("STAGE_"+stage, width-150, 65);
    textSize(fontSize);

    text(round(frameRate, 2)+"fps", width-150, 35);
    textAlign(LEFT);
}

// Looking for the functions of the dials? check the gpio.pde file

public void brainalizer(int value) {
    nextStage();
}
/* 
Terminating interrupt handling for pin X after catching: null
absturz:irgendwas mit PFFont getname()
cannot use "curveVertex()" bevore "beginShape()" in waves.pde
absturz: Nullpointerexception mit verweis zu zeile 77 (ein rect() mit nur globals?????) in helpers.pde
  */

// amplitude
int pin_0a = 19;
int pin_0b = 26;

// frequency
int pin_1a = 6;
int pin_1b = 13;

// scale
int pin_2a = 11;
int pin_2b = 5;

// noise
int pin_3a = 10;
int pin_3b = 9;


// amplitude
int value0 = 0;
int lastEncoded0 = 0;

// frequency
int value1 = 0;
int lastEncoded1 = 0;

// scale
int value2 = 0;
int lastEncoded2 = 0;

// noise
int value3 = 0;
int lastEncoded3 = 0;

// main switch & LED
  int mainSwitchPin = 17;
  int switchLedPin = 27;

public void gpioSetup() {
	// amplitude
	GPIO.pinMode(pin_0a, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.pinMode(pin_0b, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.attachInterrupt(pin_0a, this, "updateEncoder0", GPIO.CHANGE);
	GPIO.attachInterrupt(pin_0b, this, "updateEncoder0", GPIO.CHANGE);

	// frequency
	GPIO.pinMode(pin_1a, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.pinMode(pin_1b, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.attachInterrupt(pin_1a, this, "updateEncoder1", GPIO.CHANGE);
	GPIO.attachInterrupt(pin_1b, this, "updateEncoder1", GPIO.CHANGE);

	// scale
	GPIO.pinMode(pin_2a, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.pinMode(pin_2b, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.attachInterrupt(pin_2a, this, "updateEncoder2", GPIO.CHANGE);
	GPIO.attachInterrupt(pin_2b, this, "updateEncoder2", GPIO.CHANGE);

	// noise
	GPIO.pinMode(pin_3a, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.pinMode(pin_3b, GPIO.INPUT_PULLUP);  // !PULLUP!
	GPIO.attachInterrupt(pin_3a, this, "updateEncoder3", GPIO.CHANGE);
	GPIO.attachInterrupt(pin_3b, this, "updateEncoder3", GPIO.CHANGE);

	// main switch + LED
	GPIO.pinMode(mainSwitchPin, GPIO.INPUT_PULLUP);
	GPIO.pinMode(switchLedPin, GPIO.OUTPUT);
}

public void gpioRead() {
  // this is in draw();
  // println("amplitude: "+amplitude+"\t\tfrequency: "+frequency+"\t\tscale: "+scale+"\t\tnoise: "+noise+"\t\t");

  GPIO.noInterrupts();
  if(lastEncoded0 != 0) {
    amplitudeKnob(amplitude + value0*ampDialSpeedFactor);
    value0 = 0;
	lastEncoded0 = 0;
  }

  if(lastEncoded1 != 0) {
    frequencyKnob(frequency + value1*freqDialSpeedFactor);
    value1 = 0;
	lastEncoded1 = 0;
  }

  if(lastEncoded2 != 0) {
    scaleKnob(scale + value2*scaleDialSpeedFactor);
    value2 = 0;
	lastEncoded2 = 0;
  }

  if(lastEncoded3 != 0) {
    noiseKnob(noise + value3*noiseDialSpeedFactor);
    value3 = 0;
	lastEncoded3 = 0;
  }
  GPIO.interrupts();
}


// amplitude
public void updateEncoder0(int pin) {
  	GPIO.noInterrupts();
	int MSB = GPIO.digitalRead(pin_0a);
	int LSB = GPIO.digitalRead(pin_0b);
	int encoded = (MSB << 1) | LSB;
	int sum = (lastEncoded0 << 2) | encoded;
	if (sum == unbinary("1101") || sum == unbinary("0100") || sum == unbinary("0010") || sum == unbinary("1011")) {
		value0++;
	}
	if (sum == unbinary("1110") || sum == unbinary("0111") || sum == unbinary("0001") || sum == unbinary("1000")) { 
		value0--;
	}
	lastEncoded0 = encoded;
  	GPIO.interrupts();
}

// frequency
public void updateEncoder1(int pin) {
  	GPIO.noInterrupts();
	int MSB = GPIO.digitalRead(pin_1a);
	int LSB = GPIO.digitalRead(pin_1b);
	int encoded = (MSB << 1) | LSB;
	int sum = (lastEncoded1 << 2) | encoded;
	if (sum == unbinary("1101") || sum == unbinary("0100") || sum == unbinary("0010") || sum == unbinary("1011")) {
		value1++;
	}
	if (sum == unbinary("1110") || sum == unbinary("0111") || sum == unbinary("0001") || sum == unbinary("1000")) { 
		value1--;
	}
	lastEncoded1 = encoded;
  	GPIO.interrupts();
}

// scale
public void updateEncoder2(int pin) {
  	GPIO.noInterrupts();
	int MSB = GPIO.digitalRead(pin_2a);
	int LSB = GPIO.digitalRead(pin_2b);
	int encoded = (MSB << 1) | LSB;
	int sum = (lastEncoded2 << 2) | encoded;
	if (sum == unbinary("1101") || sum == unbinary("0100") || sum == unbinary("0010") || sum == unbinary("1011")) {
		value2++;
	}
	if (sum == unbinary("1110") || sum == unbinary("0111") || sum == unbinary("0001") || sum == unbinary("1000")) { 
		value2--;
	}
	lastEncoded2 = encoded;
  	GPIO.interrupts();
}

// noise
public void updateEncoder3(int pin) {
  	GPIO.noInterrupts();
	int MSB = GPIO.digitalRead(pin_3a);
	int LSB = GPIO.digitalRead(pin_3b);
	int encoded = (MSB << 1) | LSB;
	int sum = (lastEncoded3 << 2) | encoded;
	if (sum == unbinary("1101") || sum == unbinary("0100") || sum == unbinary("0010") || sum == unbinary("1011")) {
		value3++;
	}
	if (sum == unbinary("1110") || sum == unbinary("0111") || sum == unbinary("0001") || sum == unbinary("1000")) { 
		value3--;
	}
	lastEncoded3 = encoded;
  	GPIO.interrupts();
}


// These functions are also used by the controlP5 dials
public void amplitudeKnob(int value) {
  value = clamp(value, ampMin, ampMax);
  if(stage == 3 || stage == 4) {
      amplitude = value;
      // println("Setting amplitude to "+value);
      popUp("AMPLITUDE: "+(value+333), width/4*3, 1250);  // skew printout to not have boring numbers as solution
  }
}
public void frequencyKnob(int value) {
  value = clamp(value, freqMin, freqMax);
  if(stage == 3 || stage == 4) {
      frequency = value;
      // println("Setting frequency to "+value);
      popUp("FREQUENCY: "+(value+124), width/4*3, 1250);  // skew printout to not have boring numbers as solution
  }
}
public void scaleKnob(int value) {
  value = clamp(value, scaleMin, scaleMax);
  if(stage == 3 || stage == 4) {
      // scale = width/value;
      scale = value;
      // println(scale);
      popUp("SCALE: "+value, width/4*3, 1250);
  }
}
public void noiseKnob(int value) {
  value = clamp(value, noiseMin, noiseMax);
  if(stage == 3 || stage == 4) {
      noise = value;
      // println(value);
      popUp("DE-NOISE: "+(value+416), width/4*3, 1250);  // skew printout to not have boring numbers as solution
  }
}
// DISPLAY HELPERS

public int centerX(int widthObject) {
  return width/2-widthObject/2;
}

// center between points
public int centerX(int widthObject, int minX, int maxX) {
  return (maxX-minX)/2+minX-widthObject/2;
}

public int centerY(int heightObject) {
  return wHeight/2-heightObject/2;
}

// center between points
public int centerY(int heightObject, int minY, int maxY) {
  return (maxY-minY)/2+minY-heightObject/2;
}

public int right(int widthObject, int margin) {
  return width-margin-widthObject;
}

public int bottom(int heightObject, int margin) {
  return wHeight-margin-heightObject;
}

public void centerText(String text, int y) {
    centerText(text, y, mainFontColor);
}
public void centerText(String text, int y, int fontColor) {
  fill(fontColor);
  text(text, centerX(PApplet.parseInt(textWidth(text))), y);
}

public void centerText(String text, int y, int minX, int maxX) {
  centerText(text, y, minX, maxX, mainFontColor);
}

public void centerText(String text, int y, int minX, int maxX, int fontColor) {
    fill(fontColor);
  text(text, centerX(PApplet.parseInt(textWidth(text)), minX, maxX), y);
}

public boolean isAboutEqual(int a, int b, int errorMargin) {
    return a < b+errorMargin && a > b-errorMargin;
}

public int clamp(int value, int min, int max) {
  return value < min ? min : value > max ? max : value;
}

public static float round(float number, int scale) {
    int pow = 10;
    for (int i = 1; i < scale; i++)
        pow *= 10;
    float tmp = number * pow;
    return ( (float) ( (int) ((tmp - (int) tmp) >= 0.5f ? tmp + 1 : tmp) ) ) / pow;
}


String popUpText = "";
long popUpTimeout = 0;
int popUpX = 0;
int popUpY = 0;

public void popUp(String text, int x, int y, int timeOut) {
  textSize(fontSize*1.25f);
  int w = PApplet.parseInt(textWidth(text));
  int h = lineHeight;
  stroke(mainBg);
  fill(mainBg);
  rect(x-(w+110)/2,y-h-5, w+110,h*2+10, 5);

  fill(mainFontColor);
  rect(x-(w+100)/2,y-h, w+100,h*2, 5);

  textAlign(CENTER);
  fill(mainBg);
  text(text, x, y+h/2);
  textAlign(LEFT);
  textSize(fontSize);
  
  if(timeOut>0){
    popUpText = text;
    popUpTimeout = millis()+timeOut;
    popUpX = x;
    popUpY = y;
  }
}

public void popUpAfterglow() {
  if(millis() < popUpTimeout) {
    popUp(popUpText,  popUpX,  popUpY, 0);
  } else {
    popUpText = "";
    popUpTimeout = 0;
    popUpX = 0;
    popUpY = 0;
  }
}

public void popUp(String text, int timeOut) {
  popUp(text, width/2, wHeight/2, timeOut);
}

public void popUp(String text, int x, int timeOut) {
  popUp(text, x, wHeight/2, timeOut);
}

public void preloadAllStages(float desiredFrameRate) {
  popUp("LOAD FRAMERATE: "+round(frameRate, 2)+" > "+desiredFrameRate+"fps", width/4, 0);
  popUp(round(100*frameRate/desiredFrameRate)+"%", width/4*3, 0);
  if(stage == 0) {
    goToStage(3);
  } else if(stage == 3) {
    // wait for frame rate to recover
    if(frameRate < desiredFrameRate) {
      // Last resort: resize tables to speed things up
      if(AUTOSCALE) if(millis() % 11 == 0 && wHeight > 250) wHeight -= 1;
      println("wait for framerate to be bigger than "+desiredFrameRate+": " + frameRate);  // twiddle dee
    } else {
      println("Loaded stage 3");
      goToStage(4);
    }
  } else if(stage == 4) {
    // wait for frame rate to recover
    if(frameRate < desiredFrameRate) {
      if(AUTOSCALE) if(millis() % 11 == 0 && wHeight > 250) wHeight -= 1;
      // Last resort: resize tables to speed things up
      println("wait for framerate to be bigger than "+desiredFrameRate+": " + frameRate);  // twiddle dee
    } else {
      println("Loaded stage 4");
      goToStage(0);
      popUp("Loaded & ready to rumble.", width/4*3, 6000);
      startUpLoaded = true;
      udp.send("sync_ready", remoteIp, remotePort);
    }
  }
}
public void keyPressed() {
  if (key != CODED) {
    // println(key);
    switch(key) {
        case('0'): startUpLoaded = true; goToStage(0); break;  // Blackout
        case('1'): startUpLoaded = true; goToStage(1); break;  // "Await input"
        case('2'): startUpLoaded = true; goToStage(2); break;  // "startup"
        case('3'): startUpLoaded = true; goToStage(3); break;  // Curves without user
        case('4'): startUpLoaded = true; goToStage(4); break;  // Curves with user
        case('5'): startUpLoaded = true; goToStage(5); break;  // Success!
        case('6'): startUpLoaded = true; goToStage(6); break;  // Elisas thoughts
        default: startUpLoaded = true; goToStage(0); break;
        //case('1'):myKnobA.setValue(180);break;
        //case('2'):myKnobB.setConstrained(false).hideTickMarks().snapToTickMarks(false);break;
        //case('3'):myKnobA.shuffle();myKnobB.shuffle();break;
    }
  } else {
    // println(keyCode);
    switch(keyCode) {
        case(39): startUpLoaded = true; nextStage(); break;
        case(37): startUpLoaded = true; prevStage(); break;
    }
  }
}

/*  void keyPressed() {
   if(keyCode == 10) {  // Enter
     if(message.length() > 0) {
       udp.send(message, ip, port );   // the message to send
       feedback("Enter pressed, message sent: " + message, 0,255,0);
       message = "";
     } else {
       feedback("Empty message ignored", 255,0,0);
     }
   } else if (keyCode == 8 ) {  //  backspace
     if(message.length() > 0) {
       message = message.substring(0, message.length() - 1);
     }
     feedback("Message to send: '" +message+"'");
   } else if (keyCode == 127 ) {  //  delete
     message = "";
     feedback("Message to send: '" +message+"'");
   } else if (key != CODED) {   // if printable
     message += str(key);
     feedback("Message to send: '" +message+"'");
   } else {
     feedback("Non-printing character ignored", 255,0,0);
   }
 } */
 
int scrollIndex = 0;
long nextText = 0;
boolean fin = false;

public void scrollText(String[] data, int interval, int accuracy, int x, int y, int w, int h, boolean cursor) {
    /* if(DEBUG) {
        stroke(mainFontColor);
        fill(0,0,0,0);
        rect(x,y, w,h);
    } */

    for (int i = 0; i < scrollIndex+1; i++) {
        // Deletes text after out of bounds
        if(i < data.length) {
            // When text is longer than screen, correct for scrolling.
            int corr = scrollIndex * lineHeight > h ? (scrollIndex+1-(h/lineHeight))*lineHeight : 0;
            int marginTop = lineHeight + y + i * lineHeight - corr;
            fill(mainFontColor);
            if(marginTop > y) {  // cut off lines above starting point when scrolling
                text(data[i], x, marginTop);
            }
        }
        // Cursor at the end
        if(cursor && i == scrollIndex && i < data.length) {
            if (millis() % 1000 <= 500) {
                fill(mainFontColor, 100);
                noStroke();
                rect(textWidth(data[i]) + x + fontSize/3, y + i * lineHeight + lineHeight/2.5f, fontSize/1.75f, fontSize/1.1f);
            }
        }
    }

    // Set timestamp for next text
    if (nextText < millis() && scrollIndex < data.length-1) {
        float accuracyMargin = interval*(accuracy/100);
        nextText = millis()+PApplet.parseInt(random(interval-accuracyMargin, interval+accuracyMargin));
        scrollIndex++;
    }
    
    // End reached & action for stage 2
    if(stage == 2 && scrollIndex == data.length-1) {
        println("booted_up");
        delay(4444);
        nextStage();
        println("next!");
    }
    
    // End reached & action for stage 6
    if(stage == 6 && scrollIndex == data.length-1 && !fin) {
        println("FIN");
        // MAYBE TODO / FIXME:
        //   sends this already when first text reaches end of text, not when last text is written.
        //   maybe doesn't matter because text have equal lengths,
        //   also, nothing is dependend on this message
        udp.send("sync_end_of_thoughts", remoteIp, remotePort );
        fin = true;
    }
}
   // for UDP communication
 UDP udp;  // define the UDP object
 String message = "";

// for ip & port see elisas_synchronotron
 
 // TEST CONENCTION IN TERMINAL
 // nc -u -l 8888
 // this listens to UDP on port 8888 on its own network.

 public void udpSetup() {
    udp = new UDP( this, portIncoming );  // create a new datagram connection on port 6000
    udp.log( true );     // <-- printout the connection activity
    udp.listen( true );           // and wait for incoming message
 }


  //void receive( byte[] data ) {       // <-- default handler
  public void receive( byte[] data, String ip, int port ) {  // <-- extended handler
   String message = "";
   for(int i=0; i < data.length; i++) {
     message += PApplet.parseChar(data[i]);
   }
   println("Received package on "+ip+" from port "+port+": "+message);

   // Have to use byte-wise comparison of byte array "data"
   //   because "message" and a comparable string is somehow not the same

  if(Arrays.equals(data, "sync_stage0".getBytes())) {
    // Blackout
    startUpLoaded = true;
    goToStage(0);
  
  } else if(Arrays.equals(data, "sync_stage1".getBytes())) {
    // "Await input"
    startUpLoaded = true;
    goToStage(1);
  
  } else if(Arrays.equals(data, "sync_stage2".getBytes())) {
    // "startup"
    startUpLoaded = true;
    goToStage(2);
  
  } else if(Arrays.equals(data, "sync_stage3".getBytes())) {
    // Curves without user
    startUpLoaded = true;
    goToStage(3);
  
  } else if(Arrays.equals(data, "sync_stage4".getBytes())) {
    // Curves with user
    startUpLoaded = true;
    goToStage(4);
  
  } else if(Arrays.equals(data, "sync_stage5".getBytes())) {
    // Success!
    startUpLoaded = true;
    goToStage(5);
  
  } else if(Arrays.equals(data, "sync_stage6".getBytes())) {
    // Elisas thoughts
    startUpLoaded = true;
    goToStage(6);
  
  } else if(Arrays.equals(data, "sync_skipLoading".getBytes())) {
    // Abort loading if stuck
     println("Aborted Loading by dungeon master");
     startUpLoaded = true;
     goToStage(0);
     udp.send("sync_ready", remoteIp, remotePort);
  } else {
    println("Message was not for me :(");
  }
 }
float perlinNoiseCoordY = 0.0f;
PImage[] screenshot;
int scaleMargin = PApplet.parseInt(fontSize*1.75f);

public void drawGrid(int x, int y, int w, int h, int scale) {
    // MAIN LINES   
    stroke(mainFontColor);
    line(x,y+h-scaleMargin, x+w,y+h-scaleMargin);  // horz
    line(x+scaleMargin,y, x+scaleMargin,y+h);  // vert

    // subgrid horz
    stroke(mainFontColor, 175);  // rgb + opacity 0-255: (255,255,255, 255)
    for (int i = 0; i < h-scaleMargin; i+=scale) {
        // scale*(amplitude/100)
        line(x+scaleMargin,y+h-scaleMargin-i, x+w,y+h-scaleMargin-i);
    }
    // subgrid vert
    for (int i = 0; i < w-scaleMargin; i+=scale) {
        // scale*(frequency/100)
        line(x+scaleMargin+i,y, x+scaleMargin+i,y+h-scaleMargin);
    }

    // TEXT
    textAlign(RIGHT);
    fill(mainFontColor);
    pushMatrix();
        float angle2 = radians(270);
        translate(x+fontSize, y);
        rotate(angle2);
        text("AMPLITUDE", 0,0);
    popMatrix();

    text("FREQUENCY", x+w, y+h);
    textAlign(LEFT);
    text("0", x, y+h);
    centerText("Scale "+scale+":1", y+h, x+scaleMargin, x+w);
};

public void drawCurve(int[] data, int x, int y, int w, int h, int scale, int amp, int freq, int noise) {
    stroke(mainFontColor);
    strokeWeight(lineWeight*2);  // Thicc
    noFill();
    // curveTightness(0);  // 0 ultra smooth, 1 no smoothing
    float thightness = map(noise, noiseMin, noiseMax, -1.0f, 1.0f);
    curveTightness(thightness < 0 ? thightness*-1 : thightness);

    float noiseCorr = 0;
    float perlinNoise = 0;
    // Do not completely eradicate jitter
    noise = noise < 5 && noise > -5 ? 5 : noise;// -60 to +76 = dead zone
    
    GPIO.noInterrupts();
    beginShape();
    for (int i = 0; i < data.length && (i-2)*scale*(freq/100.0f) <= w-scaleMargin; i++) {
        //if(frameRate > 5) {
            // Calculate jitter based on de-noise knob
            perlinNoiseCoordY = perlinNoiseCoordY + map(noise, 10, noiseMax, 0.001f, .1f);
            perlinNoise = noise(perlinNoiseCoordY, perlinNoiseCoordY);
            noiseCorr = perlinNoise*noise;

            // Some random spikes are more spikey
            if(i % Math.round(perlinNoise*12+1) == 0) {
                noiseCorr *= noiseCorr;
            }

            // Invert every other spike to not move the complete wave in +Y or -Y.
            //   It evens out the displacement, and basically doubles the noise effect. Noice!
            if(i % 2 == 0) noiseCorr *= -1;

            // Increase noise now and again - cannot see a difference
            /* if(perlinNoise < 0.2) {
                noiseCorr *= noiseCorr/4;
            } */
        //}
        curveVertex(x+scaleMargin+(i-1)*scale*(freq/100.0f),  map(data[i]*scale*(amp/100.0f)-PApplet.parseInt(noiseCorr), 0,1024, y+h-scaleMargin, y));
    }
    endShape();
    GPIO.interrupts();

    //Cover up overshooting curve top and bottom
    fill(mainBg);
    noStroke();
    rect(x, 0, w, y);
    rect(x+lineWeight+scaleMargin, y+h-scaleMargin, w-scaleMargin, height-wHeight-y);

    strokeWeight(lineWeight);
};

public PImage ghostingCopy(int x, int y, int w, int h) {
    return get(x, y, w, h);
}
public void ghostingPaste(PImage img, int x, int y, int w, int h) {
    image(img, x+scaleMargin, y-scaleMargin);
}

public void drawFakeApplicationNonsense(int x) {
    fill(mainFontColor);
    // monitor VGA with ca. 45 chars per line:
    // .............................................
    // Usable font glyphs in topaz8 font:
    // |\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2580\u2590\u258c\u2584\u2588\u250c\u2518\u256a\u2555\u2563\u2551\u2557\u255d\u255c\u255b\u2510\u2534\u2514\u252c\u251c\u2500\u255e\u253c\u255f\u255a\u2554\u2569\u2566\u2560\u2550\u256c\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256b\u2310\u00a9\u00ae\u00ba\u00a6[\]^_\u00ac\u00af
    text(" RXN \u2502  FL  \u2502[ SUB ]\u2502 SETUP \u2502 CLEAR \u2502 LOG ", lineHeight+x, wHeight-lineHeight/2);
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "elisas_synchronotron" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
